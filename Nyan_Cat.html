<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nyan Cat Game</title>
    <style>
      :root {
        /* 基础尺寸变量 */
        --viewport-scale: min(1, max(0.5, calc(100vw / 1920)));
        --cat-size: clamp(100px, min(18vw, 18vh), min(22vw, 22vh));
        --font-size-small: clamp(12px, 2.5vw, 14px);
        --font-size-normal: clamp(14px, 3vw, 18px);
        --font-size-large: clamp(20px, 4vw, 24px);
        --font-size-xlarge: clamp(24px, 6vw, 36px);
        --spacing-small: clamp(5px, 1.5vw, 8px);
        --spacing-normal: clamp(10px, 2vw, 20px);
        --spacing-large: clamp(20px, 5vw, 40px);
        --control-size: clamp(35px, 8vw, 45px);
      }

      /* 重置和基础样式 */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 60vh;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
        touch-action: none;
      }

      /* 游戏容器 */
      .game-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      /* 游戏画布 */
      #gameCanvas {
        position: relative;
        /* 移除定位属性，让Canvas由JS精确控制尺寸和位置 */
        /* CSS不再设置尺寸，完全由JS控制 */
      }

      /* 猫咪角色 */
      #nyanCat {
        position: absolute;
        width: var(--cat-size);
        height: var(--cat-size);
        transform: translate(-50%, -50%);
        z-index: 2;
        pointer-events: none;
        image-rendering: pixelated;
        will-change: transform;
        object-fit: contain;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
      }

      /* 分数显示 */
      .score {
        position: fixed;
        top: var(--spacing-normal);
        right: var(--spacing-normal);
        color: white;
        font-size: var(--font-size-large);
        z-index: 3;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        padding: var(--spacing-small);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        backdrop-filter: blur(3px);
      }

      /* 菜单和游戏结束界面 */
      .menu,
      .game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: var(--spacing-large);
        border-radius: clamp(12px, 3vw, 24px);
        text-align: center;
        z-index: 4;
        backdrop-filter: blur(8px);
        width: min(90%, 500px);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
      }

      .game-over {
        display: none;
      }

      /* 按钮样式 */
      .btn {
        margin: var(--spacing-normal);
        padding: var(--spacing-normal) var(--spacing-large);
        border: none;
        border-radius: 12px;
        background: #ff69b4;
        color: white;
        cursor: pointer;
        font-size: var(--font-size-normal);
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .btn:hover {
        transform: translateY(-2px);
        background: #ff8ac5;
        box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
      }

      .btn:active {
        transform: translateY(1px);
      }

      /* 标题样式 */
      .title {
        font-size: var(--font-size-xlarge);
        color: #ff69b4;
        text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        margin-bottom: var(--spacing-normal);
      }

      /* 音频控制按钮 */
      .audio-control {
        position: fixed;
        top: var(--spacing-normal);
        left: var(--spacing-normal);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.6);
        width: var(--control-size);
        height: var(--control-size);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .audio-control:hover {
        transform: scale(1.1);
        background: rgba(255, 105, 180, 0.6);
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .audio-control i {
        color: white;
        font-size: var(--font-size-normal);
      }

      .star {
        position: absolute;
        background: white;
        border-radius: 50%;
        animation: twinkle 1s infinite alternate;
      }
      @keyframes twinkle {
        0% {
          opacity: 0.2;
        }
        100% {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <audio id="bgm" loop>
      <source src="https://files.catbox.moe/eifyn7.mp3" type="audio/mpeg" />
    </audio>

    <div class="audio-control" id="audioControl">
      <i>🔊</i>
    </div>

    <div class="game-container">
      <canvas id="gameCanvas"></canvas>
      <img id="nyanCat" src="https://files.catbox.moe/zauopb.gif" alt="Nyan Cat" />
      <div class="score">得分: <span id="scoreValue">0</span></div>
      <div id="startMenu" class="menu">
        <h1 class="title">Nyan Cat</h1>
        <div>长按空格键或点击屏幕让Nyan Cat持续上升<br />松开后会自然下落<br />避开障碍物，获得高分！</div>
        <button class="btn" onclick="startGame()">开始游戏</button>
      </div>
      <div class="game-over" id="gameOver">
        <h2 class="title">游戏结束</h2>
        <p>最终得分: <span id="finalScore">0</span></p>
        <button class="btn" onclick="restartGame()">重新开始</button>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
      $(document).ready(function () {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nyanCat = document.getElementById('nyanCat');
        const bgm = document.getElementById('bgm');
        const audioControl = document.getElementById('audioControl');
        let isPlaying = false;

        // 游戏状态
        let gameState = {
          catY: 200, // 先设置一个默认值，初始化后会更新
          velocity: 0,
          gravity: 0.4,
          flyForce: -0.3,
          maxUpwardSpeed: -4,
          isFlying: false,
          score: 0,
          isGameOver: false,
          isGameStarted: false,
          isPaused: false,
          stars: [],
          obstacles: [],
          lastUpdateTime: 0,
        };

        // 控制状态
        let controlState = {
          spacePressed: false,
          mousePressed: false,
          touchActive: false,
        };

        // 游戏尺寸计算 - 基于Canvas实际尺寸计算缩放
        function calculateGameDimensions() {
          // 使用Canvas的实际尺寸（已经保持了正确比例）
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          // 游戏的理想尺寸（游戏设计的原始尺寸）
          const gameIdealWidth = 800;
          const gameIdealHeight = 600;

          // 计算缩放比例：基于Canvas实际尺寸
          const scale = Math.min(canvasWidth / gameIdealWidth, canvasHeight / gameIdealHeight);

          console.log(
            `Canvas: ${canvasWidth}×${canvasHeight}, 理想尺寸: ${gameIdealWidth}×${gameIdealHeight}, 缩放: ${scale.toFixed(
              2,
            )} (｡◕‿◕｡)`,
          );
          console.log(`🔍 实际游戏iframe可用区域约: 400×415px, 当前容器: ${canvasWidth}×${canvasHeight}`);
          console.log(
            `📊 容器比例: ${(canvasWidth / canvasHeight).toFixed(3)}, 游戏比例: ${(
              gameIdealWidth / gameIdealHeight
            ).toFixed(3)}`,
          );

          const isMobile = canvasWidth <= 400;
          const catSize = 60 * scale; // 固定猫咪基础尺寸，然后按比例缩放

          return {
            catSize,
            obstacleWidth: 20 * scale, // 障碍物宽度按比例缩放
            obstacleGap: 250 * scale, // 障碍物间距按比例缩放
            jumpForce: -8 * scale, // 跳跃力度按比例缩放
            gravity: 0.4 * scale, // 重力按比例缩放
            speed: 4 * scale, // 速度按比例缩放
            scale,
          };
        }

        // 障碍物类
        class Obstacle {
          constructor() {
            const dims = calculateGameDimensions();
            const isMobile = window.innerWidth <= 768;
            this.width = dims.obstacleWidth;

            // 优化障碍物高度
            const maxHeight = canvas.height * (isMobile ? 0.35 : 0.4);
            const minHeight = maxHeight * 0.4; // 保证有足够空间通过
            this.height = minHeight + Math.random() * (maxHeight - minHeight);

            // 确保障碍物之间有足够空间
            const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
            this.x = lastObstacle ? Math.max(lastObstacle.x + dims.obstacleGap, canvas.width) : canvas.width;

            // 优化垂直位置分布
            const availableSpace = canvas.height - this.height;
            const catSafeZone = dims.catSize * 1.5; // 猫咪安全区域

            // 将屏幕垂直方向分为三个区域：上、中、下
            const topZone = { min: catSafeZone, max: Math.max(catSafeZone + 50, canvas.height * 0.33) };
            const middleZone = { min: canvas.height * 0.33, max: canvas.height * 0.66 };
            const bottomZone = { min: canvas.height * 0.66, max: canvas.height - catSafeZone };

            // 随机选择一个区域
            const zoneRandom = Math.random();
            let selectedZone;

            // 检查各区域是否有效（确保有足够空间）
            const topZoneValid = topZone.max > topZone.min + 30;
            const bottomZoneValid = bottomZone.max > bottomZone.min + 30;

            console.log(
              `区域检查 - 上区域: ${topZone.min}-${topZone.max} (有效:${topZoneValid}), 中区域: ${middleZone.min}-${middleZone.max}, 下区域: ${bottomZone.min}-${bottomZone.max} (有效:${bottomZoneValid})`,
            );

            if (zoneRandom < 0.4 && (topZoneValid || bottomZoneValid)) {
              // 40%概率在上部或下部（但只在有效区域中选择）
              if (topZoneValid && bottomZoneValid) {
                selectedZone = Math.random() < 0.5 ? topZone : bottomZone;
              } else if (topZoneValid) {
                selectedZone = topZone;
              } else {
                selectedZone = bottomZone;
              }
            } else {
              // 60%概率在中部，或者上下区域都无效时强制中部
              selectedZone = middleZone;
            }

            // 在选定区域内随机生成位置
            const zoneHeight = selectedZone.max - selectedZone.min;
            this.y = Math.max(selectedZone.min, Math.random() * zoneHeight + selectedZone.min);

            console.log(
              `障碍物生成在区域: ${
                selectedZone === topZone ? '上' : selectedZone === middleZone ? '中' : '下'
              }, Y位置: ${this.y}`,
            );

            // 确保不会完全堵住通道
            if (this.height > canvas.height * 0.4) {
              this.height = canvas.height * 0.4;
            }

            this.speed = dims.speed;
          }

          update() {
            this.x -= this.speed;
            return this.x + this.width < 0;
          }

          draw() {
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }

          checkCollision(catX, catY) {
            const dims = calculateGameDimensions();
            const catSize = dims.catSize * (window.innerWidth <= 768 ? 0.7 : 0.6);
            return (
              catX + catSize * 0.7 > this.x &&
              catX + catSize * 0.3 < this.x + this.width &&
              catY + catSize * 0.7 > this.y &&
              catY + catSize * 0.3 < this.y + this.height
            );
          }
        }

        // 星星类
        class Star {
          constructor() {
            this.reset();
          }

          reset() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 3 + 1;
            this.speed = Math.random() * 2 + 1;
          }

          update() {
            this.x -= this.speed;
            if (this.x < 0) {
              this.reset();
              this.x = canvas.width;
            }
          }

          draw() {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // 事件处理
        function setupEventListeners() {
          const handleInput = (type, active, e) => {
            e?.preventDefault();
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            controlState[type] = active;
          };

          document.addEventListener(
            'keydown',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', true, e);
            },
            { capture: true },
          );

          document.addEventListener(
            'keyup',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', false, e);
            },
            { capture: true },
          );

          canvas.addEventListener('mousedown', e => handleInput('mousePressed', true, e));
          canvas.addEventListener('mouseup', e => handleInput('mousePressed', false, e));
          canvas.addEventListener('mouseleave', () => handleInput('mousePressed', false));

          canvas.addEventListener('touchstart', e => handleInput('touchActive', true, e), { passive: false });
          canvas.addEventListener('touchend', e => handleInput('touchActive', false, e), { passive: false });

          document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
              gameState.isPaused = true;
              Object.keys(controlState).forEach(key => (controlState[key] = false));
              isPlaying && bgm.pause();
            } else {
              gameState.isPaused = false;
              gameState.lastUpdateTime = 0;
              isPlaying && bgm.play();
            }
          });

          window.addEventListener('resize', () => {
            // 重新计算保持比例的Canvas尺寸
            initCanvas(); // 直接调用初始化函数重新计算

            const dims = calculateGameDimensions();
            document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);
            console.log(`Canvas已重新调整比例 (´∀｀)`);
          });
        }

        // 简化的星星系统
        function createStars() {
          const dims = calculateGameDimensions();
          return Array.from({ length: 100 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: (Math.random() * 2 + 1) * dims.scale, // 星星大小按比例缩放
            speed: (Math.random() * 1.5 + 0.5) * dims.scale, // 星星速度按比例缩放
          }));
        }

        function updateStars() {
          gameState.stars.forEach(star => {
            star.x -= star.speed;
            if (star.x < 0) {
              star.x = canvas.width;
              star.y = Math.random() * canvas.height;
            }
          });
        }

        function drawStars() {
          ctx.fillStyle = 'white';
          gameState.stars.forEach(star => {
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // 游戏逻辑
        function update(currentTime) {
          if (!gameState.isGameStarted || gameState.isGameOver || gameState.isPaused) return;

          const deltaTime = gameState.lastUpdateTime ? (currentTime - gameState.lastUpdateTime) / 16 : 1;
          gameState.lastUpdateTime = currentTime;

          const dims = calculateGameDimensions();
          gameState.isFlying = controlState.spacePressed || controlState.mousePressed || controlState.touchActive;

          // 更新猫咪位置
          if (gameState.isFlying) {
            gameState.velocity = Math.max(
              gameState.maxUpwardSpeed * dims.scale,
              gameState.velocity + gameState.flyForce * dims.scale * deltaTime,
            );
          } else {
            gameState.velocity += gameState.gravity * dims.scale * deltaTime;
          }

          gameState.catY += gameState.velocity * deltaTime;

          // 边界检查
          if (gameState.catY < 0) {
            gameState.catY = 0;
            gameState.velocity = 0;
          }
          if (gameState.catY > canvas.height - dims.catSize) {
            gameState.catY = canvas.height - dims.catSize;
            gameState.velocity = 0;
          }

          // 更新星星
          updateStars();

          // 优化障碍物生成
          const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
          const minGap = dims.obstacleGap * 1.2; // 增加最小间距

          if (!lastObstacle || lastObstacle.x + lastObstacle.width < canvas.width - minGap) {
            // 根据分数调整生成概率
            const baseChance = 0.01;
            const scoreMultiplier = Math.min(1 + Math.floor(gameState.score / 1000) * 0.1, 2);
            if (Math.random() < baseChance * scoreMultiplier) {
              gameState.obstacles.push(new Obstacle());
            }
          }

          // 更新和检查障碍物
          gameState.obstacles = gameState.obstacles.filter(obstacle => {
            const isOffscreen = obstacle.update();
            !isOffscreen && obstacle.checkCollision(100, gameState.catY) && gameOver();
            return !isOffscreen;
          });

          // 更新分数
          gameState.score++;
          document.getElementById('scoreValue').textContent = Math.floor(gameState.score / 10);
        }

        function draw() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 🔍 调试信息：在Canvas上显示当前尺寸和缩放
          const dims = calculateGameDimensions();
          ctx.fillStyle = '#fff';
          ctx.font = '11px Arial';
          ctx.fillText(`Canvas: ${canvas.width}×${canvas.height}`, 10, 15);
          ctx.fillText(`Scale: ${dims.scale.toFixed(2)}`, 10, 30);
          ctx.fillText(`Cat: ${dims.catSize.toFixed(1)}px`, 10, 45);
          ctx.fillText(`Expected: 400×300, 0.50, 30px`, 10, 60);
          ctx.fillText(`CatX: ${(100 * dims.scale).toFixed(1)}px`, 10, 75);

          drawStars();
          gameState.obstacles.forEach(obstacle => obstacle.draw());

          // 根据Canvas缩放计算猫咪位置
          const scaledCatX = 100 * dims.scale; // 原来固定100px，现在按比例缩放
          nyanCat.style.transform = `translate(${scaledCatX}px, ${gameState.catY}px)`;
        }

        function gameLoop() {
          update(performance.now());
          draw();
          requestAnimationFrame(gameLoop);
        }

        // 游戏控制
        window.startGame = function () {
          gameState.isGameStarted = true;
          gameState.isPaused = false;
          document.getElementById('startMenu').style.display = 'none';
          nyanCat.style.display = 'block';
          gameState.score = 0;
          document.getElementById('scoreValue').textContent = '0';

          if (bgm) {
            bgm
              .play()
              .then(() => {
                isPlaying = true;
                audioControl.innerHTML = '<i>🔊</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>❌</i>'));
          }
        };

        window.restartGame = function () {
          gameState = {
            catY: window.innerHeight / 2,
            velocity: 0,
            gravity: 0.4,
            flyForce: -0.3,
            maxUpwardSpeed: -4,
            isFlying: false,
            score: 0,
            isGameOver: false,
            isGameStarted: true,
            isPaused: false,
            stars: createStars(), // 重新创建星星
            obstacles: [],
            lastUpdateTime: 0,
          };

          Object.keys(controlState).forEach(key => (controlState[key] = false));
          document.getElementById('gameOver').style.display = 'none';
          bgm.volume = 1.0;
          isPlaying && bgm.play();
        };

        function gameOver() {
          gameState.isGameOver = true;
          document.getElementById('gameOver').style.display = 'block';
          document.getElementById('finalScore').textContent = Math.floor(gameState.score / 10);
          bgm.volume = 0.3;
        }

        // 音频控制
        audioControl.onclick = function (e) {
          e.stopPropagation();
          if (isPlaying) {
            bgm.pause();
            audioControl.innerHTML = '<i>🔈</i>';
          } else {
            bgm
              .play()
              .then(() => {
                audioControl.innerHTML = '<i>🔊</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>❌</i>'));
          }
          isPlaying = !isPlaying;
        };

        // 初始化 - 保持游戏比例，适应容器尺寸
        function initCanvas() {
          const container = document.querySelector('.game-container');
          const containerWidth = container ? container.clientWidth : 400;
          const containerHeight = container ? container.clientHeight : 300;

          // 游戏的理想比例 (4:3)
          const gameAspectRatio = 800 / 600;
          const containerAspectRatio = containerWidth / containerHeight;

          let canvasWidth, canvasHeight;

          if (containerAspectRatio > gameAspectRatio) {
            // 容器更宽，以高度为准
            canvasHeight = containerHeight;
            canvasWidth = canvasHeight * gameAspectRatio;
          } else {
            // 容器更高，以宽度为准
            canvasWidth = containerWidth;
            canvasHeight = canvasWidth / gameAspectRatio;
          }

          // 设置Canvas的实际像素尺寸
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          canvas.style.width = canvasWidth + 'px';
          canvas.style.height = canvasHeight + 'px';

          // Canvas现在由flex容器自动居中，不需要手动定位
          canvas.style.position = 'relative';
          canvas.style.left = '';
          canvas.style.top = '';
          canvas.style.transform = '';

          console.log(`📦 容器尺寸: ${containerWidth}×${containerHeight}`);
          console.log(
            `🎯 容器比例: ${containerAspectRatio.toFixed(3)} (${
              containerAspectRatio > gameAspectRatio ? '更宽' : '更高'
            })`,
          );
          console.log(`🎮 游戏比例: ${gameAspectRatio.toFixed(3)} (4:3)`);
          console.log(`🖼️ Canvas最终尺寸: ${canvasWidth}×${canvasHeight}`);
          console.log(`💡 预期效果: 如果容器是400×415，Canvas应该是400×300，缩放0.5 (´∀｀)♡`);

          // 不再触发resize事件，避免循环调用
        }

        // 延迟初始化，确保iframe完全加载
        setTimeout(() => {
          initCanvas();

          // 重新计算游戏元素尺寸（基于新的Canvas尺寸）
          const dims = calculateGameDimensions();
          console.log(
            `🎮 游戏元素重新计算: 猫咪=${dims.catSize}px, 障碍物宽度=${dims.obstacleWidth}px, 缩放=${dims.scale} (＾◡＾)`,
          );

          // 更新CSS变量
          document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);
          console.log(`🎨 CSS变量已设置: --cat-size = ${dims.catSize}px`);

          // 验证CSS变量是否生效
          setTimeout(() => {
            const computedStyle = window.getComputedStyle(document.documentElement);
            const actualCatSize = computedStyle.getPropertyValue('--cat-size');
            console.log(`🔍 实际CSS变量值: --cat-size = ${actualCatSize}`);

            const catElement = document.getElementById('nyanCat');
            if (catElement) {
              const catComputedStyle = window.getComputedStyle(catElement);
              console.log(`🐱 猫咪实际宽度: ${catComputedStyle.width}, 高度: ${catComputedStyle.height}`);
            }
          }, 50);

          // 根据实际Canvas尺寸设置猫咪初始位置
          gameState.catY = canvas.height / 2;
          console.log(`猫咪初始位置设置为Canvas中心: Y=${gameState.catY} (=^･ω･^=)`);

          nyanCat.style.display = 'none';
          bgm.volume = 1.0;
          bgm.load();
          gameState.stars = createStars(); // 重新创建星星（使用新的缩放尺寸）
          setupEventListeners();

          // 开始游戏循环
          requestAnimationFrame(gameLoop);
        }, 200);
      });
    </script>
  </body>
</html>
