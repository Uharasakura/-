<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nyan Cat Game</title>
    <style>
      :root {
        /* åŸºç¡€å°ºå¯¸å˜é‡ */
        --viewport-scale: min(1, max(0.5, calc(100vmin / 800)));
        --cat-size: clamp(60px, 12vmin, 120px);
        --font-size-small: clamp(10px, 1.8vmin, 14px);
        --font-size-normal: clamp(12px, 2.2vmin, 18px);
        --font-size-large: clamp(16px, 3vmin, 24px);
        --font-size-xlarge: clamp(20px, 4.5vmin, 36px);
        --spacing-small: clamp(4px, 1vmin, 8px);
        --spacing-normal: clamp(8px, 1.5vmin, 20px);
        --spacing-large: clamp(15px, 3vmin, 40px);
        --control-size: clamp(30px, 6vmin, 45px);
      }

      /* é‡ç½®å’ŒåŸºç¡€æ ·å¼ */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 60vh;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
        touch-action: none;
      }

      /* æ¸¸æˆå®¹å™¨ */
      .game-container {
        position: fixed;
        inset: 0;
        overflow: hidden;
      }

      /* æ¸¸æˆç”»å¸ƒ */
      #gameCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
      }

      /* çŒ«å’ªè§’è‰² */
      #nyanCat {
        position: absolute;
        width: var(--cat-size);
        height: var(--cat-size);
        transform: translate(-50%, -50%);
        z-index: 2;
        pointer-events: none;
        image-rendering: pixelated;
        will-change: transform;
        object-fit: contain;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
      }

      /* åˆ†æ•°æ˜¾ç¤º */
      .score {
        position: fixed;
        top: var(--spacing-normal);
        right: var(--spacing-normal);
        color: white;
        font-size: var(--font-size-large);
        z-index: 3;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        padding: var(--spacing-small);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        backdrop-filter: blur(3px);
      }

      /* èœå•å’Œæ¸¸æˆç»“æŸç•Œé¢ */
      .menu,
      .game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: var(--spacing-large);
        border-radius: clamp(12px, 3vw, 24px);
        text-align: center;
        z-index: 4;
        backdrop-filter: blur(8px);
        width: min(90%, 500px);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
      }

      .game-over {
        display: none;
      }

      /* æŒ‰é’®æ ·å¼ */
      .btn {
        margin: var(--spacing-normal);
        padding: var(--spacing-normal) var(--spacing-large);
        border: none;
        border-radius: 12px;
        background: #ff69b4;
        color: white;
        cursor: pointer;
        font-size: var(--font-size-normal);
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .btn:hover {
        transform: translateY(-2px);
        background: #ff8ac5;
        box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
      }

      .btn:active {
        transform: translateY(1px);
      }

      /* æ ‡é¢˜æ ·å¼ */
      .title {
        font-size: var(--font-size-xlarge);
        color: #ff69b4;
        text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        margin-bottom: var(--spacing-normal);
      }

      /* éŸ³é¢‘æ§åˆ¶æŒ‰é’® */
      .audio-control {
        position: fixed;
        top: var(--spacing-normal);
        left: var(--spacing-normal);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.6);
        width: var(--control-size);
        height: var(--control-size);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .audio-control:hover {
        transform: scale(1.1);
        background: rgba(255, 105, 180, 0.6);
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .audio-control i {
        color: white;
        font-size: var(--font-size-normal);
      }

      .star {
        position: absolute;
        background: white;
        border-radius: 50%;
        animation: twinkle 1s infinite alternate;
      }
      @keyframes twinkle {
        0% {
          opacity: 0.2;
        }
        100% {
          opacity: 1;
        }
      }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  </head>
  <body>
    <audio id="bgm" loop>
      <source src="https://files.catbox.moe/eifyn7.mp3" type="audio/mpeg" />
    </audio>

    <div class="audio-control" id="audioControl">
      <i>ğŸ”Š</i>
    </div>

    <div class="game-container">
      <canvas id="gameCanvas"></canvas>
      <img id="nyanCat" src="https://files.catbox.moe/zauopb.gif" alt="Nyan Cat" />
      <div class="score">å¾—åˆ†: <span id="scoreValue">0</span></div>
      <div id="startMenu" class="menu">
        <h1 class="title">Nyan Cat</h1>
        <div>é•¿æŒ‰ç©ºæ ¼é”®æˆ–ç‚¹å‡»å±å¹•è®©Nyan CatæŒç»­ä¸Šå‡<br />æ¾å¼€åä¼šè‡ªç„¶ä¸‹è½<br />é¿å¼€éšœç¢ç‰©ï¼Œè·å¾—é«˜åˆ†ï¼</div>
        <button class="btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
      </div>
      <div class="game-over" id="gameOver">
        <h2 class="title">æ¸¸æˆç»“æŸ</h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
        <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
      </div>
    </div>

    <script>
      $(document).ready(function () {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nyanCat = document.getElementById('nyanCat');
        const bgm = document.getElementById('bgm');
        const audioControl = document.getElementById('audioControl');
        let isPlaying = false;

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
          catY: window.innerHeight / 2,
          velocity: 0,
          gravity: 0.4,
          flyForce: -0.3,
          maxUpwardSpeed: -4,
          isFlying: false,
          score: 0,
          isGameOver: false,
          isGameStarted: false,
          isPaused: false,
          stars: [],
          obstacles: [],
          lastUpdateTime: 0,
        };

        // æ§åˆ¶çŠ¶æ€
        let controlState = {
          spacePressed: false,
          mousePressed: false,
          touchActive: false,
        };

        // æ¸¸æˆå°ºå¯¸è®¡ç®—
        function calculateGameDimensions() {
          const vw = document.documentElement.clientWidth;
          const vh = document.documentElement.clientHeight;
          const isMobile = vw <= 768;
          const scale = Math.min(1, Math.max(0.5, Math.min(vw / 1920, vh / 1080)));

          // ä½¿ç”¨vminå•ä½ç¡®ä¿åœ¨å°çª—å£ä¸­çŒ«å’ªä¸ä¼šå¤ªå°
          const viewportMin = Math.min(vw, vh);
          const catSize = Math.max(60, Math.min(120, viewportMin * 0.12));

          return {
            catSize,
            obstacleWidth: Math.min(20 * scale, vw * 0.03) * (isMobile ? 0.8 : 1.2),
            obstacleGap: Math.min(300 * scale, vw * 0.3),
            jumpForce: -8 * scale * (isMobile ? 1 : 1.2),
            gravity: 0.4 * scale * (isMobile ? 1 : 1.2),
            speed: 4 * scale * (isMobile ? 0.8 : 1),
            scale,
          };
        }

        // éšœç¢ç‰©ç±»
        class Obstacle {
          constructor() {
            const dims = calculateGameDimensions();
            const isMobile = window.innerWidth <= 768;
            this.width = dims.obstacleWidth;

            // ä¼˜åŒ–éšœç¢ç‰©é«˜åº¦
            const maxHeight = canvas.height * (isMobile ? 0.35 : 0.4);
            const minHeight = maxHeight * 0.4; // ä¿è¯æœ‰è¶³å¤Ÿç©ºé—´é€šè¿‡
            this.height = minHeight + Math.random() * (maxHeight - minHeight);

            // ç¡®ä¿éšœç¢ç‰©ä¹‹é—´æœ‰è¶³å¤Ÿç©ºé—´
            const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
            this.x = lastObstacle ? Math.max(lastObstacle.x + dims.obstacleGap, canvas.width) : canvas.width;

            // ä¼˜åŒ–å‚ç›´ä½ç½®åˆ†å¸ƒ
            const availableSpace = canvas.height - this.height;
            const catSafeZone = dims.catSize * 1.5; // çŒ«å’ªå®‰å…¨åŒºåŸŸ

            // å°†å±å¹•å‚ç›´æ–¹å‘åˆ†ä¸ºä¸‰ä¸ªåŒºåŸŸï¼šä¸Šã€ä¸­ã€ä¸‹
            const topZone = { min: catSafeZone, max: canvas.height * 0.33 };
            const middleZone = { min: canvas.height * 0.33, max: canvas.height * 0.66 };
            const bottomZone = { min: canvas.height * 0.66, max: canvas.height - catSafeZone };

            // éšæœºé€‰æ‹©ä¸€ä¸ªåŒºåŸŸ
            const zoneRandom = Math.random();
            let selectedZone;

            if (zoneRandom < 0.4) {
              // 40%æ¦‚ç‡åœ¨ä¸Šéƒ¨æˆ–ä¸‹éƒ¨
              selectedZone = Math.random() < 0.5 ? topZone : bottomZone;
            } else {
              // 60%æ¦‚ç‡åœ¨ä¸­éƒ¨
              selectedZone = middleZone;
            }

            // åœ¨é€‰å®šåŒºåŸŸå†…éšæœºç”Ÿæˆä½ç½®
            this.y = Math.random() * (selectedZone.max - selectedZone.min) + selectedZone.min;

            // ç¡®ä¿ä¸ä¼šå®Œå…¨å µä½é€šé“
            if (this.height > canvas.height * 0.4) {
              this.height = canvas.height * 0.4;
            }

            this.speed = dims.speed;
          }

          update() {
            this.x -= this.speed;
            return this.x + this.width < 0;
          }

          draw() {
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }

          checkCollision(catX, catY) {
            const dims = calculateGameDimensions();
            const catSize = dims.catSize * (window.innerWidth <= 768 ? 0.7 : 0.6);
            return (
              catX + catSize * 0.7 > this.x &&
              catX + catSize * 0.3 < this.x + this.width &&
              catY + catSize * 0.7 > this.y &&
              catY + catSize * 0.3 < this.y + this.height
            );
          }
        }

        // æ˜Ÿæ˜Ÿç±»
        class Star {
          constructor() {
            this.reset();
          }

          reset() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 3 + 1;
            this.speed = Math.random() * 2 + 1;
          }

          update() {
            this.x -= this.speed;
            if (this.x < 0) {
              this.reset();
              this.x = canvas.width;
            }
          }

          draw() {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // äº‹ä»¶å¤„ç†
        function setupEventListeners() {
          const handleInput = (type, active, e) => {
            e?.preventDefault();
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            controlState[type] = active;
          };

          document.addEventListener(
            'keydown',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', true, e);
            },
            { capture: true },
          );

          document.addEventListener(
            'keyup',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', false, e);
            },
            { capture: true },
          );

          canvas.addEventListener('mousedown', e => handleInput('mousePressed', true, e));
          canvas.addEventListener('mouseup', e => handleInput('mousePressed', false, e));
          canvas.addEventListener('mouseleave', () => handleInput('mousePressed', false));

          canvas.addEventListener('touchstart', e => handleInput('touchActive', true, e), { passive: false });
          canvas.addEventListener('touchend', e => handleInput('touchActive', false, e), { passive: false });

          document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
              gameState.isPaused = true;
              Object.keys(controlState).forEach(key => (controlState[key] = false));
              isPlaying && bgm.pause();
            } else {
              gameState.isPaused = false;
              gameState.lastUpdateTime = 0;
              isPlaying && bgm.play();
            }
          });

          window.addEventListener('resize', () => {
            canvas.width = document.documentElement.clientWidth;
            canvas.height = document.documentElement.clientHeight;
            const dims = calculateGameDimensions();
            document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);
          });
        }

        // ç®€åŒ–çš„æ˜Ÿæ˜Ÿç³»ç»Ÿ
        function createStars() {
          return Array.from({ length: 100 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 1,
            speed: Math.random() * 1.5 + 0.5,
          }));
        }

        function updateStars() {
          gameState.stars.forEach(star => {
            star.x -= star.speed;
            if (star.x < 0) {
              star.x = canvas.width;
              star.y = Math.random() * canvas.height;
            }
          });
        }

        function drawStars() {
          ctx.fillStyle = 'white';
          gameState.stars.forEach(star => {
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // æ¸¸æˆé€»è¾‘
        function update(currentTime) {
          if (!gameState.isGameStarted || gameState.isGameOver || gameState.isPaused) return;

          const deltaTime = gameState.lastUpdateTime ? (currentTime - gameState.lastUpdateTime) / 16 : 1;
          gameState.lastUpdateTime = currentTime;

          const dims = calculateGameDimensions();
          gameState.isFlying = controlState.spacePressed || controlState.mousePressed || controlState.touchActive;

          // æ›´æ–°çŒ«å’ªä½ç½®
          if (gameState.isFlying) {
            gameState.velocity = Math.max(
              gameState.maxUpwardSpeed * dims.scale,
              gameState.velocity + gameState.flyForce * dims.scale * deltaTime,
            );
          } else {
            gameState.velocity += gameState.gravity * dims.scale * deltaTime;
          }

          gameState.catY += gameState.velocity * deltaTime;

          // è¾¹ç•Œæ£€æŸ¥
          if (gameState.catY < 0) {
            gameState.catY = 0;
            gameState.velocity = 0;
          }
          if (gameState.catY > canvas.height - dims.catSize) {
            gameState.catY = canvas.height - dims.catSize;
            gameState.velocity = 0;
          }

          // æ›´æ–°æ˜Ÿæ˜Ÿ
          updateStars();

          // ä¼˜åŒ–éšœç¢ç‰©ç”Ÿæˆ
          const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
          const minGap = dims.obstacleGap * 0.8; // å‡å°‘æœ€å°é—´è·ï¼Œå¢åŠ å¯†åº¦

          if (!lastObstacle || lastObstacle.x + lastObstacle.width < canvas.width - minGap) {
            // æ ¹æ®åˆ†æ•°è°ƒæ•´ç”Ÿæˆæ¦‚ç‡ - æé«˜åŸºç¡€æ¦‚ç‡
            const baseChance = 0.015; // ä»0.01æé«˜åˆ°0.015
            const scoreMultiplier = Math.min(1 + Math.floor(gameState.score / 500) * 0.15, 2.5); // æ›´å¿«å¢é•¿

            // æ·»åŠ è¿ç»­ç”Ÿæˆæœºåˆ¶
            const shouldGenerate = Math.random() < baseChance * scoreMultiplier;
            const isEarlyGame = gameState.score < 2000;
            const forceGenerate = isEarlyGame && gameState.obstacles.length === 0 && Math.random() < 0.3;

            if (shouldGenerate || forceGenerate) {
              gameState.obstacles.push(new Obstacle());

              // æœ‰æ¦‚ç‡è¿ç»­ç”Ÿæˆç¬¬äºŒä¸ªéšœç¢ç‰©ï¼ˆå¢åŠ æŒ‘æˆ˜æ€§ï¼‰
              if (gameState.score > 1000 && Math.random() < 0.25) {
                setTimeout(() => {
                  if (gameState.isGameStarted && !gameState.isGameOver) {
                    gameState.obstacles.push(new Obstacle());
                  }
                }, 800 + Math.random() * 600); // 0.8-1.4ç§’åç”Ÿæˆ
              }
            }
          }

          // æ›´æ–°å’Œæ£€æŸ¥éšœç¢ç‰©
          gameState.obstacles = gameState.obstacles.filter(obstacle => {
            const isOffscreen = obstacle.update();
            !isOffscreen && obstacle.checkCollision(100, gameState.catY) && gameOver();
            return !isOffscreen;
          });

          // æ›´æ–°åˆ†æ•°
          gameState.score++;
          document.getElementById('scoreValue').textContent = Math.floor(gameState.score / 10);
        }

        function draw() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawStars();
          gameState.obstacles.forEach(obstacle => obstacle.draw());
          nyanCat.style.transform = `translate(100px, ${gameState.catY}px)`;
        }

        function gameLoop() {
          update(performance.now());
          draw();
          requestAnimationFrame(gameLoop);
        }

        // æ¸¸æˆæ§åˆ¶
        window.startGame = function () {
          gameState.isGameStarted = true;
          gameState.isPaused = false;
          document.getElementById('startMenu').style.display = 'none';
          nyanCat.style.display = 'block';
          gameState.score = 0;
          document.getElementById('scoreValue').textContent = '0';

          if (bgm) {
            bgm
              .play()
              .then(() => {
                isPlaying = true;
                audioControl.innerHTML = '<i>ğŸ”Š</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>âŒ</i>'));
          }
        };

        window.restartGame = function () {
          gameState = {
            catY: window.innerHeight / 2,
            velocity: 0,
            gravity: 0.4,
            flyForce: -0.3,
            maxUpwardSpeed: -4,
            isFlying: false,
            score: 0,
            isGameOver: false,
            isGameStarted: true,
            isPaused: false,
            stars: createStars(), // é‡æ–°åˆ›å»ºæ˜Ÿæ˜Ÿ
            obstacles: [],
            lastUpdateTime: 0,
          };

          Object.keys(controlState).forEach(key => (controlState[key] = false));
          document.getElementById('gameOver').style.display = 'none';
          bgm.volume = 1.0;
          isPlaying && bgm.play();
        };

        function gameOver() {
          gameState.isGameOver = true;
          document.getElementById('gameOver').style.display = 'block';
          document.getElementById('finalScore').textContent = Math.floor(gameState.score / 10);
          bgm.volume = 0.3;
        }

        // éŸ³é¢‘æ§åˆ¶
        audioControl.onclick = function (e) {
          e.stopPropagation();
          if (isPlaying) {
            bgm.pause();
            audioControl.innerHTML = '<i>ğŸ”ˆ</i>';
          } else {
            bgm
              .play()
              .then(() => {
                audioControl.innerHTML = '<i>ğŸ”Š</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>âŒ</i>'));
          }
          isPlaying = !isPlaying;
        };

        // åˆå§‹åŒ–
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;

        // åˆå§‹åŒ–æ—¶ä¹Ÿè¦æ›´æ–°CSSå˜é‡ï¼Œç¡®ä¿çŒ«å’ªåœ¨å°çª—å£ä¸­å¤§å°åˆé€‚
        const dims = calculateGameDimensions();
        document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);

        nyanCat.style.display = 'none';
        bgm.volume = 1.0;
        bgm.load();
        gameState.stars = createStars(); // åˆå§‹åŒ–æ˜Ÿæ˜Ÿ
        setupEventListeners();
        gameLoop();
      });
    </script>
  </body>
</html>
