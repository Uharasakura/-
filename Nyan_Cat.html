<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nyan Cat Game</title>
    <style>
      :root {
        /* åŸºç¡€å°ºå¯¸å˜é‡ */
        --viewport-scale: min(1, max(0.5, calc(100vw / 1920)));
        --cat-size: clamp(100px, min(18vw, 18vh), min(22vw, 22vh));
        --font-size-small: clamp(12px, 2.5vw, 14px);
        --font-size-normal: clamp(14px, 3vw, 18px);
        --font-size-large: clamp(20px, 4vw, 24px);
        --font-size-xlarge: clamp(24px, 6vw, 36px);
        --spacing-small: clamp(5px, 1.5vw, 8px);
        --spacing-normal: clamp(10px, 2vw, 20px);
        --spacing-large: clamp(20px, 5vw, 40px);
        --control-size: clamp(35px, 8vw, 45px);
      }

      /* é‡ç½®å’ŒåŸºç¡€æ ·å¼ */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 60vh;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
        touch-action: none;
      }

      /* æ¸¸æˆå®¹å™¨ */
      .game-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      /* æ¸¸æˆç”»å¸ƒ */
      #gameCanvas {
        position: relative;
        /* ç§»é™¤å®šä½å±æ€§ï¼Œè®©Canvasç”±JSç²¾ç¡®æ§åˆ¶å°ºå¯¸å’Œä½ç½® */
        /* CSSä¸å†è®¾ç½®å°ºå¯¸ï¼Œå®Œå…¨ç”±JSæ§åˆ¶ */
      }

      /* çŒ«å’ªè§’è‰² */
      #nyanCat {
        position: absolute;
        width: var(--cat-size);
        height: var(--cat-size);
        transform: translate(-50%, -50%);
        z-index: 2;
        pointer-events: none;
        image-rendering: pixelated;
        will-change: transform;
        object-fit: contain;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
      }

      /* åˆ†æ•°æ˜¾ç¤º */
      .score {
        position: fixed;
        top: var(--spacing-normal);
        right: var(--spacing-normal);
        color: white;
        font-size: var(--font-size-large);
        z-index: 3;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        padding: var(--spacing-small);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        backdrop-filter: blur(3px);
      }

      /* èœå•å’Œæ¸¸æˆç»“æŸç•Œé¢ */
      .menu,
      .game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: var(--spacing-large);
        border-radius: clamp(12px, 3vw, 24px);
        text-align: center;
        z-index: 4;
        backdrop-filter: blur(8px);
        width: min(90%, 500px);
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
      }

      .game-over {
        display: none;
      }

      /* æŒ‰é’®æ ·å¼ */
      .btn {
        margin: var(--spacing-normal);
        padding: var(--spacing-normal) var(--spacing-large);
        border: none;
        border-radius: 12px;
        background: #ff69b4;
        color: white;
        cursor: pointer;
        font-size: var(--font-size-normal);
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .btn:hover {
        transform: translateY(-2px);
        background: #ff8ac5;
        box-shadow: 0 6px 20px rgba(255, 105, 180, 0.4);
      }

      .btn:active {
        transform: translateY(1px);
      }

      /* æ ‡é¢˜æ ·å¼ */
      .title {
        font-size: var(--font-size-xlarge);
        color: #ff69b4;
        text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        margin-bottom: var(--spacing-normal);
      }

      /* éŸ³é¢‘æ§åˆ¶æŒ‰é’® */
      .audio-control {
        position: fixed;
        top: var(--spacing-normal);
        left: var(--spacing-normal);
        z-index: 1000;
        background: rgba(0, 0, 0, 0.6);
        width: var(--control-size);
        height: var(--control-size);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .audio-control:hover {
        transform: scale(1.1);
        background: rgba(255, 105, 180, 0.6);
        box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
      }

      .audio-control i {
        color: white;
        font-size: var(--font-size-normal);
      }

      .star {
        position: absolute;
        background: white;
        border-radius: 50%;
        animation: twinkle 1s infinite alternate;
      }
      @keyframes twinkle {
        0% {
          opacity: 0.2;
        }
        100% {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <audio id="bgm" loop>
      <source src="https://files.catbox.moe/eifyn7.mp3" type="audio/mpeg" />
    </audio>

    <div class="audio-control" id="audioControl">
      <i>ğŸ”Š</i>
    </div>

    <div class="game-container">
      <canvas id="gameCanvas"></canvas>
      <img id="nyanCat" src="https://files.catbox.moe/zauopb.gif" alt="Nyan Cat" />
      <div class="score">å¾—åˆ†: <span id="scoreValue">0</span></div>
      <div id="startMenu" class="menu">
        <h1 class="title">Nyan Cat</h1>
        <div>é•¿æŒ‰ç©ºæ ¼é”®æˆ–ç‚¹å‡»å±å¹•è®©Nyan CatæŒç»­ä¸Šå‡<br />æ¾å¼€åä¼šè‡ªç„¶ä¸‹è½<br />é¿å¼€éšœç¢ç‰©ï¼Œè·å¾—é«˜åˆ†ï¼</div>
        <button class="btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
      </div>
      <div class="game-over" id="gameOver">
        <h2 class="title">æ¸¸æˆç»“æŸ</h2>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
        <button class="btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
      $(document).ready(function () {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nyanCat = document.getElementById('nyanCat');
        const bgm = document.getElementById('bgm');
        const audioControl = document.getElementById('audioControl');
        let isPlaying = false;

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
          catY: 200, // å…ˆè®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼ï¼Œåˆå§‹åŒ–åä¼šæ›´æ–°
          velocity: 0,
          gravity: 0.4,
          flyForce: -0.3,
          maxUpwardSpeed: -4,
          isFlying: false,
          score: 0,
          isGameOver: false,
          isGameStarted: false,
          isPaused: false,
          stars: [],
          obstacles: [],
          lastUpdateTime: 0,
        };

        // æ§åˆ¶çŠ¶æ€
        let controlState = {
          spacePressed: false,
          mousePressed: false,
          touchActive: false,
        };

        // æ¸¸æˆå°ºå¯¸è®¡ç®— - åŸºäºCanvaså®é™…å°ºå¯¸è®¡ç®—ç¼©æ”¾
        function calculateGameDimensions() {
          // ä½¿ç”¨Canvasçš„å®é™…å°ºå¯¸ï¼ˆå·²ç»ä¿æŒäº†æ­£ç¡®æ¯”ä¾‹ï¼‰
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          // æ¸¸æˆçš„ç†æƒ³å°ºå¯¸ï¼ˆæ¸¸æˆè®¾è®¡çš„åŸå§‹å°ºå¯¸ï¼‰
          const gameIdealWidth = 800;
          const gameIdealHeight = 600;

          // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼šåŸºäºCanvaså®é™…å°ºå¯¸
          const scale = Math.min(canvasWidth / gameIdealWidth, canvasHeight / gameIdealHeight);

          console.log(
            `Canvas: ${canvasWidth}Ã—${canvasHeight}, ç†æƒ³å°ºå¯¸: ${gameIdealWidth}Ã—${gameIdealHeight}, ç¼©æ”¾: ${scale.toFixed(
              2,
            )} (ï½¡â—•â€¿â—•ï½¡)`,
          );
          console.log(`ğŸ” å®é™…æ¸¸æˆiframeå¯ç”¨åŒºåŸŸçº¦: 400Ã—415px, å½“å‰å®¹å™¨: ${canvasWidth}Ã—${canvasHeight}`);
          console.log(
            `ğŸ“Š å®¹å™¨æ¯”ä¾‹: ${(canvasWidth / canvasHeight).toFixed(3)}, æ¸¸æˆæ¯”ä¾‹: ${(
              gameIdealWidth / gameIdealHeight
            ).toFixed(3)}`,
          );

          const isMobile = canvasWidth <= 400;
          const catSize = 60 * scale; // å›ºå®šçŒ«å’ªåŸºç¡€å°ºå¯¸ï¼Œç„¶åæŒ‰æ¯”ä¾‹ç¼©æ”¾

          return {
            catSize,
            obstacleWidth: 20 * scale, // éšœç¢ç‰©å®½åº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾
            obstacleGap: 250 * scale, // éšœç¢ç‰©é—´è·æŒ‰æ¯”ä¾‹ç¼©æ”¾
            jumpForce: -8 * scale, // è·³è·ƒåŠ›åº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾
            gravity: 0.4 * scale, // é‡åŠ›æŒ‰æ¯”ä¾‹ç¼©æ”¾
            speed: 4 * scale, // é€Ÿåº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾
            scale,
          };
        }

        // éšœç¢ç‰©ç±»
        class Obstacle {
          constructor() {
            const dims = calculateGameDimensions();
            const isMobile = window.innerWidth <= 768;
            this.width = dims.obstacleWidth;

            // ä¼˜åŒ–éšœç¢ç‰©é«˜åº¦
            const maxHeight = canvas.height * (isMobile ? 0.35 : 0.4);
            const minHeight = maxHeight * 0.4; // ä¿è¯æœ‰è¶³å¤Ÿç©ºé—´é€šè¿‡
            this.height = minHeight + Math.random() * (maxHeight - minHeight);

            // ç¡®ä¿éšœç¢ç‰©ä¹‹é—´æœ‰è¶³å¤Ÿç©ºé—´
            const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
            this.x = lastObstacle ? Math.max(lastObstacle.x + dims.obstacleGap, canvas.width) : canvas.width;

            // ä¼˜åŒ–å‚ç›´ä½ç½®åˆ†å¸ƒ
            const availableSpace = canvas.height - this.height;
            const catSafeZone = dims.catSize * 1.5; // çŒ«å’ªå®‰å…¨åŒºåŸŸ

            // å°†å±å¹•å‚ç›´æ–¹å‘åˆ†ä¸ºä¸‰ä¸ªåŒºåŸŸï¼šä¸Šã€ä¸­ã€ä¸‹
            const topZone = { min: catSafeZone, max: Math.max(catSafeZone + 50, canvas.height * 0.33) };
            const middleZone = { min: canvas.height * 0.33, max: canvas.height * 0.66 };
            const bottomZone = { min: canvas.height * 0.66, max: canvas.height - catSafeZone };

            // éšæœºé€‰æ‹©ä¸€ä¸ªåŒºåŸŸ
            const zoneRandom = Math.random();
            let selectedZone;

            // æ£€æŸ¥å„åŒºåŸŸæ˜¯å¦æœ‰æ•ˆï¼ˆç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´ï¼‰
            const topZoneValid = topZone.max > topZone.min + 30;
            const bottomZoneValid = bottomZone.max > bottomZone.min + 30;

            console.log(
              `åŒºåŸŸæ£€æŸ¥ - ä¸ŠåŒºåŸŸ: ${topZone.min}-${topZone.max} (æœ‰æ•ˆ:${topZoneValid}), ä¸­åŒºåŸŸ: ${middleZone.min}-${middleZone.max}, ä¸‹åŒºåŸŸ: ${bottomZone.min}-${bottomZone.max} (æœ‰æ•ˆ:${bottomZoneValid})`,
            );

            if (zoneRandom < 0.4 && (topZoneValid || bottomZoneValid)) {
              // 40%æ¦‚ç‡åœ¨ä¸Šéƒ¨æˆ–ä¸‹éƒ¨ï¼ˆä½†åªåœ¨æœ‰æ•ˆåŒºåŸŸä¸­é€‰æ‹©ï¼‰
              if (topZoneValid && bottomZoneValid) {
                selectedZone = Math.random() < 0.5 ? topZone : bottomZone;
              } else if (topZoneValid) {
                selectedZone = topZone;
              } else {
                selectedZone = bottomZone;
              }
            } else {
              // 60%æ¦‚ç‡åœ¨ä¸­éƒ¨ï¼Œæˆ–è€…ä¸Šä¸‹åŒºåŸŸéƒ½æ— æ•ˆæ—¶å¼ºåˆ¶ä¸­éƒ¨
              selectedZone = middleZone;
            }

            // åœ¨é€‰å®šåŒºåŸŸå†…éšæœºç”Ÿæˆä½ç½®
            const zoneHeight = selectedZone.max - selectedZone.min;
            this.y = Math.max(selectedZone.min, Math.random() * zoneHeight + selectedZone.min);

            console.log(
              `éšœç¢ç‰©ç”Ÿæˆåœ¨åŒºåŸŸ: ${
                selectedZone === topZone ? 'ä¸Š' : selectedZone === middleZone ? 'ä¸­' : 'ä¸‹'
              }, Yä½ç½®: ${this.y}`,
            );

            // ç¡®ä¿ä¸ä¼šå®Œå…¨å µä½é€šé“
            if (this.height > canvas.height * 0.4) {
              this.height = canvas.height * 0.4;
            }

            this.speed = dims.speed;
          }

          update() {
            this.x -= this.speed;
            return this.x + this.width < 0;
          }

          draw() {
            ctx.fillStyle = '#ff69b4';
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }

          checkCollision(catX, catY) {
            const dims = calculateGameDimensions();
            const catSize = dims.catSize * (window.innerWidth <= 768 ? 0.7 : 0.6);
            return (
              catX + catSize * 0.7 > this.x &&
              catX + catSize * 0.3 < this.x + this.width &&
              catY + catSize * 0.7 > this.y &&
              catY + catSize * 0.3 < this.y + this.height
            );
          }
        }

        // æ˜Ÿæ˜Ÿç±»
        class Star {
          constructor() {
            this.reset();
          }

          reset() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 3 + 1;
            this.speed = Math.random() * 2 + 1;
          }

          update() {
            this.x -= this.speed;
            if (this.x < 0) {
              this.reset();
              this.x = canvas.width;
            }
          }

          draw() {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // äº‹ä»¶å¤„ç†
        function setupEventListeners() {
          const handleInput = (type, active, e) => {
            e?.preventDefault();
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            controlState[type] = active;
          };

          document.addEventListener(
            'keydown',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', true, e);
            },
            { capture: true },
          );

          document.addEventListener(
            'keyup',
            e => {
              if (e.code === 'Space' || e.key === ' ') handleInput('spacePressed', false, e);
            },
            { capture: true },
          );

          canvas.addEventListener('mousedown', e => handleInput('mousePressed', true, e));
          canvas.addEventListener('mouseup', e => handleInput('mousePressed', false, e));
          canvas.addEventListener('mouseleave', () => handleInput('mousePressed', false));

          canvas.addEventListener('touchstart', e => handleInput('touchActive', true, e), { passive: false });
          canvas.addEventListener('touchend', e => handleInput('touchActive', false, e), { passive: false });

          document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
              gameState.isPaused = true;
              Object.keys(controlState).forEach(key => (controlState[key] = false));
              isPlaying && bgm.pause();
            } else {
              gameState.isPaused = false;
              gameState.lastUpdateTime = 0;
              isPlaying && bgm.play();
            }
          });

          window.addEventListener('resize', () => {
            // é‡æ–°è®¡ç®—ä¿æŒæ¯”ä¾‹çš„Canvaså°ºå¯¸
            initCanvas(); // ç›´æ¥è°ƒç”¨åˆå§‹åŒ–å‡½æ•°é‡æ–°è®¡ç®—

            const dims = calculateGameDimensions();
            document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);
            console.log(`Canvaså·²é‡æ–°è°ƒæ•´æ¯”ä¾‹ (Â´âˆ€ï½€)`);
          });
        }

        // ç®€åŒ–çš„æ˜Ÿæ˜Ÿç³»ç»Ÿ
        function createStars() {
          const dims = calculateGameDimensions();
          return Array.from({ length: 100 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: (Math.random() * 2 + 1) * dims.scale, // æ˜Ÿæ˜Ÿå¤§å°æŒ‰æ¯”ä¾‹ç¼©æ”¾
            speed: (Math.random() * 1.5 + 0.5) * dims.scale, // æ˜Ÿæ˜Ÿé€Ÿåº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾
          }));
        }

        function updateStars() {
          gameState.stars.forEach(star => {
            star.x -= star.speed;
            if (star.x < 0) {
              star.x = canvas.width;
              star.y = Math.random() * canvas.height;
            }
          });
        }

        function drawStars() {
          ctx.fillStyle = 'white';
          gameState.stars.forEach(star => {
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        // æ¸¸æˆé€»è¾‘
        function update(currentTime) {
          if (!gameState.isGameStarted || gameState.isGameOver || gameState.isPaused) return;

          const deltaTime = gameState.lastUpdateTime ? (currentTime - gameState.lastUpdateTime) / 16 : 1;
          gameState.lastUpdateTime = currentTime;

          const dims = calculateGameDimensions();
          gameState.isFlying = controlState.spacePressed || controlState.mousePressed || controlState.touchActive;

          // æ›´æ–°çŒ«å’ªä½ç½®
          if (gameState.isFlying) {
            gameState.velocity = Math.max(
              gameState.maxUpwardSpeed * dims.scale,
              gameState.velocity + gameState.flyForce * dims.scale * deltaTime,
            );
          } else {
            gameState.velocity += gameState.gravity * dims.scale * deltaTime;
          }

          gameState.catY += gameState.velocity * deltaTime;

          // è¾¹ç•Œæ£€æŸ¥
          if (gameState.catY < 0) {
            gameState.catY = 0;
            gameState.velocity = 0;
          }
          if (gameState.catY > canvas.height - dims.catSize) {
            gameState.catY = canvas.height - dims.catSize;
            gameState.velocity = 0;
          }

          // æ›´æ–°æ˜Ÿæ˜Ÿ
          updateStars();

          // ä¼˜åŒ–éšœç¢ç‰©ç”Ÿæˆ
          const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
          const minGap = dims.obstacleGap * 1.2; // å¢åŠ æœ€å°é—´è·

          if (!lastObstacle || lastObstacle.x + lastObstacle.width < canvas.width - minGap) {
            // æ ¹æ®åˆ†æ•°è°ƒæ•´ç”Ÿæˆæ¦‚ç‡
            const baseChance = 0.01;
            const scoreMultiplier = Math.min(1 + Math.floor(gameState.score / 1000) * 0.1, 2);
            if (Math.random() < baseChance * scoreMultiplier) {
              gameState.obstacles.push(new Obstacle());
            }
          }

          // æ›´æ–°å’Œæ£€æŸ¥éšœç¢ç‰©
          gameState.obstacles = gameState.obstacles.filter(obstacle => {
            const isOffscreen = obstacle.update();
            !isOffscreen && obstacle.checkCollision(100, gameState.catY) && gameOver();
            return !isOffscreen;
          });

          // æ›´æ–°åˆ†æ•°
          gameState.score++;
          document.getElementById('scoreValue').textContent = Math.floor(gameState.score / 10);
        }

        function draw() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // ğŸ” è°ƒè¯•ä¿¡æ¯ï¼šåœ¨Canvasä¸Šæ˜¾ç¤ºå½“å‰å°ºå¯¸å’Œç¼©æ”¾
          const dims = calculateGameDimensions();
          ctx.fillStyle = '#fff';
          ctx.font = '11px Arial';
          ctx.fillText(`Canvas: ${canvas.width}Ã—${canvas.height}`, 10, 15);
          ctx.fillText(`Scale: ${dims.scale.toFixed(2)}`, 10, 30);
          ctx.fillText(`Cat: ${dims.catSize.toFixed(1)}px`, 10, 45);
          ctx.fillText(`Expected: 400Ã—300, 0.50, 30px`, 10, 60);
          ctx.fillText(`CatX: ${(100 * dims.scale).toFixed(1)}px`, 10, 75);

          drawStars();
          gameState.obstacles.forEach(obstacle => obstacle.draw());

          // æ ¹æ®Canvasç¼©æ”¾è®¡ç®—çŒ«å’ªä½ç½®
          const scaledCatX = 100 * dims.scale; // åŸæ¥å›ºå®š100pxï¼Œç°åœ¨æŒ‰æ¯”ä¾‹ç¼©æ”¾
          nyanCat.style.transform = `translate(${scaledCatX}px, ${gameState.catY}px)`;
        }

        function gameLoop() {
          update(performance.now());
          draw();
          requestAnimationFrame(gameLoop);
        }

        // æ¸¸æˆæ§åˆ¶
        window.startGame = function () {
          gameState.isGameStarted = true;
          gameState.isPaused = false;
          document.getElementById('startMenu').style.display = 'none';
          nyanCat.style.display = 'block';
          gameState.score = 0;
          document.getElementById('scoreValue').textContent = '0';

          if (bgm) {
            bgm
              .play()
              .then(() => {
                isPlaying = true;
                audioControl.innerHTML = '<i>ğŸ”Š</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>âŒ</i>'));
          }
        };

        window.restartGame = function () {
          gameState = {
            catY: window.innerHeight / 2,
            velocity: 0,
            gravity: 0.4,
            flyForce: -0.3,
            maxUpwardSpeed: -4,
            isFlying: false,
            score: 0,
            isGameOver: false,
            isGameStarted: true,
            isPaused: false,
            stars: createStars(), // é‡æ–°åˆ›å»ºæ˜Ÿæ˜Ÿ
            obstacles: [],
            lastUpdateTime: 0,
          };

          Object.keys(controlState).forEach(key => (controlState[key] = false));
          document.getElementById('gameOver').style.display = 'none';
          bgm.volume = 1.0;
          isPlaying && bgm.play();
        };

        function gameOver() {
          gameState.isGameOver = true;
          document.getElementById('gameOver').style.display = 'block';
          document.getElementById('finalScore').textContent = Math.floor(gameState.score / 10);
          bgm.volume = 0.3;
        }

        // éŸ³é¢‘æ§åˆ¶
        audioControl.onclick = function (e) {
          e.stopPropagation();
          if (isPlaying) {
            bgm.pause();
            audioControl.innerHTML = '<i>ğŸ”ˆ</i>';
          } else {
            bgm
              .play()
              .then(() => {
                audioControl.innerHTML = '<i>ğŸ”Š</i>';
              })
              .catch(() => (audioControl.innerHTML = '<i>âŒ</i>'));
          }
          isPlaying = !isPlaying;
        };

        // åˆå§‹åŒ– - ä¿æŒæ¸¸æˆæ¯”ä¾‹ï¼Œé€‚åº”å®¹å™¨å°ºå¯¸
        function initCanvas() {
          const container = document.querySelector('.game-container');
          const containerWidth = container ? container.clientWidth : 400;
          const containerHeight = container ? container.clientHeight : 300;

          // æ¸¸æˆçš„ç†æƒ³æ¯”ä¾‹ (4:3)
          const gameAspectRatio = 800 / 600;
          const containerAspectRatio = containerWidth / containerHeight;

          let canvasWidth, canvasHeight;

          if (containerAspectRatio > gameAspectRatio) {
            // å®¹å™¨æ›´å®½ï¼Œä»¥é«˜åº¦ä¸ºå‡†
            canvasHeight = containerHeight;
            canvasWidth = canvasHeight * gameAspectRatio;
          } else {
            // å®¹å™¨æ›´é«˜ï¼Œä»¥å®½åº¦ä¸ºå‡†
            canvasWidth = containerWidth;
            canvasHeight = canvasWidth / gameAspectRatio;
          }

          // è®¾ç½®Canvasçš„å®é™…åƒç´ å°ºå¯¸
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          canvas.style.width = canvasWidth + 'px';
          canvas.style.height = canvasHeight + 'px';

          // Canvasç°åœ¨ç”±flexå®¹å™¨è‡ªåŠ¨å±…ä¸­ï¼Œä¸éœ€è¦æ‰‹åŠ¨å®šä½
          canvas.style.position = 'relative';
          canvas.style.left = '';
          canvas.style.top = '';
          canvas.style.transform = '';

          console.log(`ğŸ“¦ å®¹å™¨å°ºå¯¸: ${containerWidth}Ã—${containerHeight}`);
          console.log(
            `ğŸ¯ å®¹å™¨æ¯”ä¾‹: ${containerAspectRatio.toFixed(3)} (${
              containerAspectRatio > gameAspectRatio ? 'æ›´å®½' : 'æ›´é«˜'
            })`,
          );
          console.log(`ğŸ® æ¸¸æˆæ¯”ä¾‹: ${gameAspectRatio.toFixed(3)} (4:3)`);
          console.log(`ğŸ–¼ï¸ Canvasæœ€ç»ˆå°ºå¯¸: ${canvasWidth}Ã—${canvasHeight}`);
          console.log(`ğŸ’¡ é¢„æœŸæ•ˆæœ: å¦‚æœå®¹å™¨æ˜¯400Ã—415ï¼ŒCanvasåº”è¯¥æ˜¯400Ã—300ï¼Œç¼©æ”¾0.5 (Â´âˆ€ï½€)â™¡`);

          // ä¸å†è§¦å‘resizeäº‹ä»¶ï¼Œé¿å…å¾ªç¯è°ƒç”¨
        }

        // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿iframeå®Œå…¨åŠ è½½
        setTimeout(() => {
          initCanvas();

          // é‡æ–°è®¡ç®—æ¸¸æˆå…ƒç´ å°ºå¯¸ï¼ˆåŸºäºæ–°çš„Canvaså°ºå¯¸ï¼‰
          const dims = calculateGameDimensions();
          console.log(
            `ğŸ® æ¸¸æˆå…ƒç´ é‡æ–°è®¡ç®—: çŒ«å’ª=${dims.catSize}px, éšœç¢ç‰©å®½åº¦=${dims.obstacleWidth}px, ç¼©æ”¾=${dims.scale} (ï¼¾â—¡ï¼¾)`,
          );

          // æ›´æ–°CSSå˜é‡
          document.documentElement.style.setProperty('--cat-size', `${dims.catSize}px`);
          console.log(`ğŸ¨ CSSå˜é‡å·²è®¾ç½®: --cat-size = ${dims.catSize}px`);

          // éªŒè¯CSSå˜é‡æ˜¯å¦ç”Ÿæ•ˆ
          setTimeout(() => {
            const computedStyle = window.getComputedStyle(document.documentElement);
            const actualCatSize = computedStyle.getPropertyValue('--cat-size');
            console.log(`ğŸ” å®é™…CSSå˜é‡å€¼: --cat-size = ${actualCatSize}`);

            const catElement = document.getElementById('nyanCat');
            if (catElement) {
              const catComputedStyle = window.getComputedStyle(catElement);
              console.log(`ğŸ± çŒ«å’ªå®é™…å®½åº¦: ${catComputedStyle.width}, é«˜åº¦: ${catComputedStyle.height}`);
            }
          }, 50);

          // æ ¹æ®å®é™…Canvaså°ºå¯¸è®¾ç½®çŒ«å’ªåˆå§‹ä½ç½®
          gameState.catY = canvas.height / 2;
          console.log(`çŒ«å’ªåˆå§‹ä½ç½®è®¾ç½®ä¸ºCanvasä¸­å¿ƒ: Y=${gameState.catY} (=^ï½¥Ï‰ï½¥^=)`);

          nyanCat.style.display = 'none';
          bgm.volume = 1.0;
          bgm.load();
          gameState.stars = createStars(); // é‡æ–°åˆ›å»ºæ˜Ÿæ˜Ÿï¼ˆä½¿ç”¨æ–°çš„ç¼©æ”¾å°ºå¯¸ï¼‰
          setupEventListeners();

          // å¼€å§‹æ¸¸æˆå¾ªç¯
          requestAnimationFrame(gameLoop);
        }, 200);
      });
    </script>
  </body>
</html>
